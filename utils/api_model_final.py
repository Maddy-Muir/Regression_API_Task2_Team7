# -*- coding: utf-8 -*-
"""Working Copy of Karin_Clean_Data 29-05.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1s_AJgdM-ihm_DR7qZ0XGpDj0U4T9eRpX

# Predict Instruction

Build a model that predicts an accurate delivery time, from picking up a package to arriving at the final destination. An accurate arrival time prediction will help all businesses to improve their logistics and communicate an accurate time to their customers.

## Import packages
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
pd.set_option('display.max_columns', 60)

import seaborn as sns
sns.set(font_scale=1)

# for the Q-Q plots
import scipy.stats as stats

# to split and standarize the dataset
from sklearn.preprocessing import StandardScaler

# Machine Learning Models
from sklearn.linear_model import LinearRegression
from sklearn.linear_model import Lasso
from sklearn.linear_model import Ridge
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from sklearn.tree import DecisionTreeRegressor
from catboost import CatBoostRegressor
from sklearn import ensemble

# to evaluate the regression model
from sklearn.metrics import mean_squared_error

# Hyperparameter tuning
from sklearn.model_selection import RandomizedSearchCV, GridSearchCV

train_df = pd.read_csv('https://raw.githubusercontent.com/Maddy-Muir/team_7_regression/master/Data/Train.csv')
riders_df = pd.read_csv('https://raw.githubusercontent.com/Maddy-Muir/team_7_regression/master/Data/Riders.csv')

training_df = pd.merge(train_df, riders_df, how = 'inner', on = 'Rider Id')
training_df = training_df.drop(['Vehicle Type', 'Temperature', 'Precipitation in millimeters' ], axis = 1)

#Extract time
time_df = training_df.copy()

#Convert to 24 hours
time_df['Placement - Time'] = pd.DatetimeIndex(time_df['Placement - Time']).time
time_df['Confirmation - Time'] = pd.DatetimeIndex(time_df['Confirmation - Time']).time
time_df['Arrival at Pickup - Time'] = pd.DatetimeIndex(time_df['Arrival at Pickup - Time']).time
time_df['Pickup - Time'] = pd.DatetimeIndex(time_df['Pickup - Time']).time

time_df[['Placement_Hour','Placement_Minute','Placement_Seconds']] = time_df['Placement - Time'].astype(str).str.split(':', expand=True).astype(int)
time_df[['Confirmation_Hour','Confirmation_Minute','Confirmation_Seconds']] = time_df['Confirmation - Time'].astype(str).str.split(':', expand=True).astype(int)
time_df[['Arrival_at_Pickup_Hour','Arrival_at_Pickup_Minute','Arrival_at_Pickup_Seconds']] = time_df['Arrival at Pickup - Time'].astype(str).str.split(':', expand=True).astype(int)
time_df[['Pickup_Hour','Pickup_Minute','Pickup_Seconds']] = time_df['Pickup - Time'].astype(str).str.split(':', expand=True).astype(int)

training_df = training_df.drop(['User Id', 'Platform Type'], axis = 1)
print(training_df.columns)

def dummy_encode_columns(input_df, column_name):
    dummy_df = pd.get_dummies(input_df, columns = [column_name], drop_first = True)
    return dummy_df

training_df = dummy_encode_columns(training_df, 'Personal or Business')
print(training_df.columns)
exit()

def diff_check_drop_col(df, col_1, col_2):
  diff_check_drop_col = df[col_1] - df[col_2]
  x = diff_check_drop_col.value_counts()
  if x.loc[0] > len(df.index)*0.95:
    df = df.drop([col_2], axis = 1)
  return df

training_df = diff_check_drop_col(training_df, "Confirmation - Day of Month", "Placement - Day of Month")
training_df = diff_check_drop_col(training_df, "Arrival at Pickup - Day of Month", "Confirmation - Day of Month")
training_df = diff_check_drop_col(training_df,"Pickup - Day of Month" ,"Arrival at Pickup - Day of Month")
training_df = diff_check_drop_col(training_df,'Arrival at Destination - Day of Month',"Pickup - Day of Month")
training_df = training_df.drop(["Arrival at Destination - Day of Month"], axis = 1)
training_df = training_df.drop(['Placement - Weekday (Mo = 1)','Confirmation - Weekday (Mo = 1)','Arrival at Pickup - Weekday (Mo = 1)',
                          'Pickup - Weekday (Mo = 1)','Arrival at Destination - Weekday (Mo = 1)'], axis = 1)

training_time_cols = ['Placement - Time', 'Confirmation - Time', 'Arrival at Pickup - Time', 
                      'Pickup - Time', 'Arrival at Destination - Time']

for time in training_time_cols:
    training_df[time] = pd.to_datetime(training_df[time])

training_df['Time Difference - Placement to Confirmation'] = (training_df['Confirmation - Time'] - training_df['Placement - Time']).dt.total_seconds()
training_df['Time Difference - Confirmation to Arrival at Pickup'] = (training_df['Arrival at Destination - Time'] - training_df['Confirmation - Time']).dt.total_seconds()
training_df['Time Difference - Arrival at Pickup to Pickup'] = (training_df['Pickup - Time'] - training_df['Arrival at Pickup - Time']).dt.total_seconds()
training_df['Time Difference - Pickup to Arrival at Destination'] = (training_df['Arrival at Destination - Time'] - training_df['Pickup - Time']).dt.total_seconds()

training_df = training_df.drop(['Placement - Time', 'Confirmation - Time', 
                                'Arrival at Pickup - Time', 'Pickup - Time', 
                                'Arrival at Destination - Time'], axis = 1)

training_df = training_df.drop(['Time Difference - Pickup to Arrival at Destination'], axis = 1)

"""##Harvesine Distance - Converting Longitude/Latitude to a value"""

def haversine(lat1, lon1, lat2, lon2, to_radians = True, earth_radius = 6371):
    """
    Modified version: of http://stackoverflow.com/a/29546836/2901002

    Calculate the great circle distance between two points
    on the earth (specified in decimal degrees or in radians)

    All (lat, lon) coordinates must have numeric dtypes and be of equal length.

    """
    if to_radians:
        lat1, lon1, lat2, lon2 = np.radians([lat1, lon1, lat2, lon2])

    a = np.sin((lat2-lat1)/2.0)**2 + \
        np.cos(lat1) * np.cos(lat2) * np.sin((lon2-lon1)/2.0)**2

    return earth_radius * 2 * np.arcsin(np.sqrt(a))


training_df['Distance'] = haversine(training_df['Pickup Lat'], 
                                training_df['Pickup Long'],
                                training_df['Destination Lat'], 
                                training_df['Destination Long'])

"""# Change Rider ID to only be a code"""

def extract_id(input_df):
    input_df['Rider Id'] = input_df['Rider Id'].str.extract(r"([0-9]+)").astype(int)
    return input_df

extract_id(training_df)

training_df['Speed (KM/H)'] = training_df['Distance (KM)']/(training_df['Time from Pickup to Arrival']/3600)
speed_df = training_df[(training_df['Speed (KM/H)'] <= 80)]

#reorder columns
speed_df = speed_df.filter(['Pickup Lat', 'Pickup Long', 'Destination Lat',
       'Destination Long', 'Distance (KM)', 'Rider Id',
       'No_Of_Orders', 'Age', 'Average_Rating', 'No_of_Ratings',
       'Personal or Business_Personal',
       'Time Difference - Placement to Confirmation',
       'Time Difference - Confirmation to Arrival at Pickup',
       'Time Difference - Arrival at Pickup to Pickup', 'Distance',
       'Speed (KM/H)', 'Time from Pickup to Arrival'], axis=1)

final_features = speed_df.drop(['Distance', 'Time Difference - Confirmation to Arrival at Pickup', 'No_of_Ratings', 'No_Of_Orders'], axis=1)

final_features = final_features.filter(['Order No', 'Pickup Lat', 'Pickup Long', 'Destination Lat', 'Destination Long',
       'Rider Id', 'Age', 'Average_Rating','Personal or Business_Personal',
       'Time Difference - Placement to Confirmation',
       'Time Difference - Arrival at Pickup to Pickup', 
       'Distance (KM)', 'Speed (KM/H)', 'Time from Pickup to Arrival'], axis=1)

final_features = final_features.drop('Speed (KM/H)', axis=1)

from sklearn.model_selection import train_test_split
from sklearn.model_selection import KFold

X = final_features.drop(columns='Time from Pickup to Arrival')
y = pd.DataFrame(final_features['Time from Pickup to Arrival'])

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.3, random_state = 42)

feature_names = final_features.drop('Time from Pickup to Arrival', axis=1).columns.tolist()

model = ensemble.GradientBoostingRegressor()
model.fit(X,y)

from sklearn.preprocessing import MinMaxScaler

mms = MinMaxScaler(feature_range=(0, 1))
mms.fit(X_train)
X_train = mms.transform(X_train)
X_test = mms.transform(X_test)

y_train = np.array(y_train).reshape((-1, ))
y_test = np.array(y_test).reshape((-1, ))

# Function to calculate RMSE
def rmse(y_true, y_pred):
    return np.sqrt(np.mean((y_pred - y_test)**2))

# Takes in a model, trains the model, and evaluates the model on the test set
def fit_and_evaluate(model):
    
    # Train the model
    model.fit(X_train, y_train)
    
    # Make predictions and evalute
    model_pred = model.predict(X_test)
    model_rmse = rmse(y_test, model_pred)
    
    # Return the performance metric
    return model_rmse

#Linear Regression
lr = LinearRegression()
lr_rmse = fit_and_evaluate(lr)

#Lasso regression
lasso = Lasso()
lasso_rmse = fit_and_evaluate(lasso)

#Ridge regression
ridge = Ridge()
ridge_rmse = fit_and_evaluate(ridge)

#Decision tree
dec_tree = DecisionTreeRegressor(max_depth=3)
dec_tree_rmse = fit_and_evaluate(dec_tree)

# #Random Forest
# random_forest = RandomForestRegressor()
# random_forest_rmse = fit_and_evaluate(random_forest)

#Gradient boosted
gradient_boosted = GradientBoostingRegressor()
gradient_boosted_rmse = fit_and_evaluate(gradient_boosted)

#Catboost
catboost = CatBoostRegressor(logging_level='Silent')
catboost_rmse = fit_and_evaluate(gradient_boosted)


def train_and_validate(columns, model):
     features = final_features[columns]
     target = final_features['Time from Pickup to Arrival']
     
     train_mses = []
     train_rmses = []
     test_mses = []
     test_rmses = []

     folds = KFold(n_splits=5, shuffle=True)

     for train_index, test_index in folds.split(features):
          x_train, x_test = features.iloc[train_index], features.iloc[test_index]    
          y_train, y_test = target.iloc[train_index], target.iloc[test_index]
     
          #model = LinearRegression()
          model.fit(x_train, y_train)
          train_predictions = model.predict(x_train)
          test_predictions = model.predict(x_test)
     
          train_mse = mean_squared_error(y_train, train_predictions)
          train_rmse = train_mse**0.5
          train_mses.append(train_mse)
          train_rmses.append(train_rmse)
     
          test_mse = mean_squared_error(y_test, test_predictions)
          test_rmse = test_mse**0.5
          test_mses.append(test_mse)
          test_rmses.append(test_rmse)
    
     
     avg_train_rmse = np.mean(train_rmses)
     avg_test_rmse = np.mean(test_rmses)

     return [avg_train_rmse, avg_test_rmse]

features = final_features.drop(['Time from Pickup to Arrival', 'Rider Id'], axis=1)
features = features.columns
features

cat_boost = CatBoostRegressor(silent = True)
cat_boost.fit(speed_df[features], speed_df['Time from Pickup to Arrival'])

#Pickle model for use within our API
import pickle
save_path = '../assets/trained-models/team7_sendy_simple_lm_regression.pkl'
print (f"Training completed. Saving model to: {save_path}")
pickle.dump(cat_boost, open(save_path,'wb'))

